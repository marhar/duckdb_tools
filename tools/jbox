#!/bin/bash
HELP="\
usage: jbox
Have some json or csv in the clipboard, then run this script.
Interactive commands:
  j: load JSON from clipboard
  c: load CSV from clipboard
  -: decrease font size
  =: increase font size
  0: reset font size to default
  q: quit
  ESC: escape key
  ↑: up arrow
  ↓: down arrow
  ←: left arrow
  →: right arrow
  Page Up/Down: scroll data
  Home/End: go to start/end of data
  Tab: navigate between views
  Enter: select/drill down
"
# TODO: add history
#    0 = go to most recent; 1 = go to next most recent; 2 = go to next most recent; etc.

display() {
  # echo font:$(osascript -e 'tell application "Terminal" to return font size of front window')
  duckdb -c "
    SELECT * from b;SELECT * from a;
  " $F
  duckdb -noheader -ascii -c "
    SELECT string_agg(column_name, ',' ORDER BY ordinal_position) z
    FROM information_schema.columns
    WHERE table_schema = 'main' AND table_name = 'a';
  " $F
}

load_common() {
  duckdb -c "
    CREATE OR REPLACE TABLE b AS
    UNPIVOT (
      select * FROM a LIMIT 1
    )
    ON COLUMNS(*)
    INTO
      NAME name
      VALUE value
    ORDER BY name;
  " $F
}

load_json () {
  pbpaste | duckdb -c "
    CREATE OR REPLACE TABLE a AS SELECT columns(*)::text FROM read_json('/dev/stdin');
  " $F
  load_common

}

load_csv () {
  pbpaste | duckdb -c "
    CREATE OR REPLACE TABLE a AS SELECT columns(*)::text FROM read_csv('/dev/stdin');
    CREATE TABLE b AS
    UNPIVOT (
      select * FROM a LIMIT 1
    )
    ON COLUMNS(*)
    INTO
      NAME name
      VALUE value
    ORDER BY name;
  " $F
}

font_size() {
    local delta=$1
    if [[ $delta == "reset" ]]; then
	osascript -e 'tell application "Terminal" to set font size of front window to 12'
    elif [[ $delta == "up" ]]; then
	osascript -e 'tell application "Terminal" to set font size of front window to (font size of front window) + 1'
    elif [[ $delta == "down" ]]; then
	osascript -e 'tell application "Terminal" to set font size of front window to (font size of front window) - 1'
    fi
}

cleanup() {
    rm -rf $D
    stty echo icanon
}

#----------------------------------------------------

D=$(mktemp -d)
F=$D/f.db

trap cleanup 0
trap display WINCH

stty -echo -icanon min 1 time 0

load_json
display

read_key() {
    IFS= read -r -n1 key
    if [[ $key == $'\e' ]]; then
        read -r -n2 -t 0.001 rest
        if [[ -z "$rest" ]]; then
            # If no additional characters were read, it's a standalone ESC key
            key="ESC"
        else
            key+="$rest"
            # For some sequences, we need to read additional bytes
            if [[ "$rest" == "[" ]]; then
                # It might be Home, End, Page Up/Down which have longer sequences
                read -r -n1 -t 0.001 extra
                if [[ "$extra" == [0-9] ]]; then
                    key+="$extra"
                    # Read the final character (e.g. for Home key: \e[1~)
                    read -r -n1 -t 0.001 final
                    key+="$final"
                fi
            fi
        fi
    fi
    echo "$key"
}

while true; do
    char=$(read_key)
    case "$char" in
        "j")
            load_json
            display
            ;;
        "c")
            load_csv
            display
            ;;
        "-")
            font_size down
            ;;
        "=")
            font_size up
            ;;
        "0")
            font_size reset
            ;;
        "q")
            exit 0
            ;;
        "?")
            echo "$HELP"
            ;;
        "ESC")
            echo "ESC key pressed"
            ;;
        $'\e[A')
            echo "Up arrow pressed"
            ;;
        $'\e[B')
            echo "Down arrow pressed"
            ;;
        $'\e[C')
            echo "Right arrow pressed"
            ;;
        $'\e[D')
            echo "Left arrow pressed"
            ;;
        $'\e[5~')
            echo "Page Up pressed"
            ;;
        $'\e[6~')
            echo "Page Down pressed"
            ;;
        $'\e[H')
            echo "Home pressed"
            ;;
        $'\e[F')
            echo "End pressed"
            ;;
        $'\e[1~')
            echo "Home pressed (alternate code)"
            ;;
        $'\e[4~')
            echo "End pressed (alternate code)"
            ;;
        $'\e[3~')
            echo "Delete pressed"
            ;;
        $'\t')
            echo "Tab pressed"
            ;;
        $'\n')
            echo "Enter pressed"
            ;;
        *)
            # Debug output for unrecognized keys
            if [[ "$char" == $'\e'* ]]; then
                # For escape sequences, show the hex codes
                hex_repr=$(printf "%s" "$char" | hexdump -v -e '/1 "0x%02X "')
                echo "Unrecognized key sequence: $hex_repr"
            elif [[ $(printf "%d" "'$char'") -lt 32 ]]; then
                # For control characters
                dec_val=$(printf "%d" "'$char'")
                echo "Control character: ^$(printf \\$(printf '%03o' $((dec_val + 64))))"
            else
                echo "Unrecognized key: '$char'"
            fi
            echo "Press 'j' to load JSON, 'c' to load CSV, 'q' to quit, or '?' for help."
            ;;
    esac
done
